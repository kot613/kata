"""
Однажды, на пути через старый дикий горный запад,…
…человеку дали указание пройти из одной точки в другую. Направления были «СЕВЕР», «ЮГ», «ЗАПАД», «ВОСТОК».
Ясно, что "СЕВЕР" и "ЮГ" противоположны, "ЗАПАД" и "ВОСТОК" тоже.

Идти в одном направлении и сразу же возвращаться в противоположном направлении — бесполезное усилие.
Так как это дикий запад, с ужасной погодой и небольшим количеством воды, важно экономить немного энергии, иначе вы
можете умереть от жажды!

Как я ловко пересек горную пустыню.
Указания, данные мужчине, например, следующие (в зависимости от языка):
["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"].
or
{ "NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST" };
or
[North, South, South, East, West, North, West]
Сразу видно, что идти "НА СЕВЕР" и сразу "ЮГ" неразумно, лучше оставайтесь на том же месте!
Итак, задача состоит в том, чтобы дать человеку упрощённый вариант плана. Лучший план в этом случае просто:

Напишите функцию dirReduc, которая будет принимать массив строк и возвращать массив строк с
удаленными ненужными направлениями (W<->E или S<->N рядом).

Версия Haskell принимает список направлений с данными Direction = North | Восток | Запад | Юг.
Версия Clojure возвращает nil, когда путь сводится к нулю.
Версия Rust использует часть перечисления Direction {North, East, West, South}.
"""


def dirReduc(arr):
    dir_dct = {"NORTH": "SOUTH", "SOUTH": "NORTH", "WEST": "EAST", "EAST": "WEST"}
    ans = []
    for direction in arr:
        if ans:
            if dir_dct[ans[-1]] != direction:
                ans.append(direction)
            else:
                del ans[-1]
        else:
            ans.append(direction)
    return ans



a = ["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"]
dirReduc(a)
u=["NORTH", "WEST", "SOUTH", "EAST"]
dirReduc(u)